To connect your Kotlin game to your Go backend, Retrofit is the industry standard. It handles the JSON conversion and network buffering automatically, which is critical in a game loop where you cannot afford to block the main thread.
Here is the complete Network Module for Drift Miner.
1. The Dependencies (build.gradle)
First, you need to add these to your app-level build.gradle file to enable Retrofit and Gson (for JSON parsing).
dependencies {
    // Networking
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
    
    // Coroutines (for background network calls)
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
}

2. The Network Data Model (NetworkModels.kt)
This class mirrors the Go struct we created in the previous step. Retrofit uses this to turn your Kotlin object into JSON.
package com.example.driftminer.network

import com.google.gson.annotations.SerializedName

data class ScoreSubmission(
    @SerializedName("username") val username: String,
    @SerializedName("score") val score: Int,
    @SerializedName("level") val level: Int,
    @SerializedName("platform") val platform: String = "android"
    // Note: 'timestamp' is generated by the server
    // Note: 'user_id' will eventually come from the Auth Token header
)

3. The API Interface (DriftMinerApi.kt)
This interface defines your endpoints. Notice the suspend keywordâ€”this integrates with Kotlin Coroutines so the network call doesn't freeze your game.
package com.example.driftminer.network

import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.GET
import retrofit2.http.POST

interface DriftMinerApi {

    // Matches Go Route: /api/v1/submit-score
    @POST("/api/v1/submit-score")
    suspend fun submitScore(@Body score: ScoreSubmission): Response<Void>

    // Matches Go Route: /api/v1/leaderboard
    @GET("/api/v1/leaderboard")
    suspend fun getLeaderboard(): List<ScoreSubmission>
}

4. The Network Client (NetworkClient.kt)
We use a "Singleton" object here so we don't keep creating expensive network connections every time the game ends.
Replace YOUR_APP_ENGINE_URL with the actual URL Google gives you after deployment (e.g., https://drift-miner-game.uc.r.appspot.com).
package com.example.driftminer.network

import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object NetworkClient {
    
    // TODO: Swap this with your real App Engine URL later
    private const val BASE_URL = "https://your-project-id.uc.r.appspot.com" 

    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    val api: DriftMinerApi = retrofit.create(DriftMinerApi::class.java)
}

5. Hooking it into the Game
Now, let's update your GameView.kt to actually send the score when the player dies.
We need to launch a Coroutine (a background thread) so the UI doesn't stutter.
// ... inside GameView.kt ...

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import com.example.driftminer.network.NetworkClient
import com.example.driftminer.network.ScoreSubmission

// ... inside checkCollisions() ...

    // B. Enemy Collision (Game Over check)
    for (e in enemies) {
        if (distSq(playerPos.x, playerPos.y, e.x, e.y) < pow2(shipRadius + e.radius)) {
            
            // 1. Capture the Final Score
            val finalScore = score
            val finalLevel = currentLevel
            
            // 2. Send to Backend (Run in Background IO thread)
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val submission = ScoreSubmission(
                        username = "Player1", // Replace with real input later
                        score = finalScore,
                        level = finalLevel
                    )
                    
                    val response = NetworkClient.api.submitScore(submission)
                    
                    if (response.isSuccessful) {
                        println("Score uploaded successfully!")
                    } else {
                        println("Upload failed: ${response.code()}")
                    }
                } catch (e: Exception) {
                    println("Network error: ${e.message}")
                }
            }

            // 3. Reset Game
            score = 0
            startLevel(1)
            return
        }
    }

Critical Final Step: Permissions
Don't forget to open your AndroidManifest.xml and add the internet permission above the <application> tag, or the app will crash instantly when it tries to connect.
<uses-permission android:name="android.permission.INTERNET" />

Summary of Progress
You now have:
 * Core Game: Physics and loop (Kotlin).
 * Backend: Server and Database (Go + Firestore).
 * Bridge: Network client (Retrofit) to connect them.
That is a complete vertical slice of a modern mobile game!
Is there anything else you need for this project before you archive it to GitHub, or would you like to switch gears to the Classroom 500 project?
